/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Main Service
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  type MutationFunction,
  type QueryClient,
  type UseMutationOptions,
  type UseMutationResult,
} from '@tanstack/react-query'
import { customMutator } from '../../mutator'
import type {
  HttpValidationError,
  LoginRequest,
  LogoutRequest,
  TokenPairResponse,
  TokenRefreshRequest,
  TokenRefreshResponse,
} from '../../schemas'

/**
 * Authenticate the user and issue access and refresh tokens to start a new session.
 * @summary Login User
 */
export const loginApiV1AuthLoginPost = (loginRequest: LoginRequest, signal?: AbortSignal) => {
  return customMutator<TokenPairResponse>({
    url: `/api/v1/auth/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: loginRequest,
    signal,
  })
}

export const getLoginApiV1AuthLoginPostMutationOptions = <
  TError = HttpValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
    TError,
    { data: LoginRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationKey = ['loginApiV1AuthLoginPost']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
    { data: LoginRequest }
  > = (props) => {
    const { data } = props ?? {}

    return loginApiV1AuthLoginPost(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type LoginApiV1AuthLoginPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>
>
export type LoginApiV1AuthLoginPostMutationBody = LoginRequest
export type LoginApiV1AuthLoginPostMutationError = HttpValidationError

/**
 * @summary Login User
 */
export const useLoginApiV1AuthLoginPost = <TError = HttpValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
      TError,
      { data: LoginRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
  TError,
  { data: LoginRequest },
  TContext
> => {
  const mutationOptions = getLoginApiV1AuthLoginPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Use a refresh token to issue a new access token and maintain the user session.
 * @summary Refresh Access Token
 */
export const refreshAccessTokenApiV1AuthRefreshPost = (
  tokenRefreshRequest: TokenRefreshRequest,
  signal?: AbortSignal,
) => {
  return customMutator<TokenRefreshResponse>({
    url: `/api/v1/auth/refresh`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tokenRefreshRequest,
    signal,
  })
}

export const getRefreshAccessTokenApiV1AuthRefreshPostMutationOptions = <
  TError = HttpValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshAccessTokenApiV1AuthRefreshPost>>,
    TError,
    { data: TokenRefreshRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshAccessTokenApiV1AuthRefreshPost>>,
  TError,
  { data: TokenRefreshRequest },
  TContext
> => {
  const mutationKey = ['refreshAccessTokenApiV1AuthRefreshPost']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshAccessTokenApiV1AuthRefreshPost>>,
    { data: TokenRefreshRequest }
  > = (props) => {
    const { data } = props ?? {}

    return refreshAccessTokenApiV1AuthRefreshPost(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type RefreshAccessTokenApiV1AuthRefreshPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshAccessTokenApiV1AuthRefreshPost>>
>
export type RefreshAccessTokenApiV1AuthRefreshPostMutationBody = TokenRefreshRequest
export type RefreshAccessTokenApiV1AuthRefreshPostMutationError = HttpValidationError

/**
 * @summary Refresh Access Token
 */
export const useRefreshAccessTokenApiV1AuthRefreshPost = <
  TError = HttpValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshAccessTokenApiV1AuthRefreshPost>>,
      TError,
      { data: TokenRefreshRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof refreshAccessTokenApiV1AuthRefreshPost>>,
  TError,
  { data: TokenRefreshRequest },
  TContext
> => {
  const mutationOptions = getRefreshAccessTokenApiV1AuthRefreshPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Revoke the refresh token to log the user out and end the current session.
 * @summary Logout User
 */
export const logoutApiV1AuthLogoutPost = (logoutRequest: LogoutRequest, signal?: AbortSignal) => {
  return customMutator<null>({
    url: `/api/v1/auth/logout`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: logoutRequest,
    signal,
  })
}

export const getLogoutApiV1AuthLogoutPostMutationOptions = <
  TError = HttpValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
    TError,
    { data: LogoutRequest },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
  TError,
  { data: LogoutRequest },
  TContext
> => {
  const mutationKey = ['logoutApiV1AuthLogoutPost']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
    { data: LogoutRequest }
  > = (props) => {
    const { data } = props ?? {}

    return logoutApiV1AuthLogoutPost(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type LogoutApiV1AuthLogoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>
>
export type LogoutApiV1AuthLogoutPostMutationBody = LogoutRequest
export type LogoutApiV1AuthLogoutPostMutationError = HttpValidationError

/**
 * @summary Logout User
 */
export const useLogoutApiV1AuthLogoutPost = <TError = HttpValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
      TError,
      { data: LogoutRequest },
      TContext
    >
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
  TError,
  { data: LogoutRequest },
  TContext
> => {
  const mutationOptions = getLogoutApiV1AuthLogoutPostMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
