// scripts/generateDtoSchema.mjs
import fs from 'fs/promises'
import path from 'path'
import process from 'process'
import { pathToFileURL } from 'url'

// --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
const DEFAULT_SCHEMA_PATH = 'src/shared/api/main/schema.ts' // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π –ø—É—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
const DEFAULT_SEARCH_DIR = 'src/shared/api' // –ü–∞–ø–∫–∞ –¥–ª—è –∞–≤—Ç–æ–ø–æ–∏—Å–∫–∞, –µ—Å–ª–∏ —Å—Ö–µ–º–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –Ω–∞–π–¥–µ–Ω–∞
const TARGET_FILENAME = 'dto.ts'

// --- –•–ï–õ–ü–ï–†–´ ---
const toPascalCase = (str) => str.charAt(0).toUpperCase() + str.slice(1)

async function findSchemaFiles(dir) {
  let results = []
  try {
    const dirents = await fs.readdir(dir, { withFileTypes: true })
    for (const dirent of dirents) {
      const resolvedPath = path.resolve(dir, dirent.name)
      if (dirent.isDirectory()) {
        results = results.concat(await findSchemaFiles(resolvedPath))
      } else if (dirent.name === 'schema.ts') {
        results.push(resolvedPath)
      }
    }
  } catch (error) {
    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –µ—Å–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞
    if (error.code !== 'ENOENT') throw error
  }
  return results
}

// --- –û–°–ù–û–í–ù–ê–Ø –õ–û–ì–ò–ö–ê ---
const main = async () => {
  try {
    const [, , entityName, targetPathInput, schemaPathInput] = process.argv

    if (!entityName || !targetPathInput) {
      console.error(
        '‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: node scripts/generateDtoSchema.mjs <EntityName> <TargetDirectory> [SchemaPath]',
      )
      process.exit(1)
    }

    const entity = toPascalCase(entityName)
    let schemaPath = ''

    if (schemaPathInput) {
      // 1. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ø—É—Ç—å, —É–∫–∞–∑–∞–Ω–Ω—ã–π –≤—Ä—É—á–Ω—É—é.
      schemaPath = path.resolve(schemaPathInput)
      console.log(`‚ÑπÔ∏è  –ò—Å–ø–æ–ª—å–∑—É—é —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø—É—Ç—å –∫ —Å—Ö–µ–º–µ: ${schemaPath}`)
    } else {
      // 2. –ü—É—Ç—å –Ω–µ —É–∫–∞–∑–∞–Ω, –ø—Ä–æ–±—É–µ–º –ø—É—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
      const defaultPath = path.resolve(DEFAULT_SCHEMA_PATH)
      try {
        await fs.access(defaultPath)
        schemaPath = defaultPath
        console.log(`‚ÑπÔ∏è  –ò—Å–ø–æ–ª—å–∑—É—é —Å—Ö–µ–º—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: ${schemaPath}`)
      } catch {
        // 3. –°—Ö–µ–º–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –Ω–∞—á–∏–Ω–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫.
        const searchDir = path.resolve(DEFAULT_SEARCH_DIR)
        console.warn(
          `üü° –°—Ö–µ–º–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–∏–Ω–∞—é –ø–æ–∏—Å–∫ 'schema.ts' –≤ ${searchDir}...`,
        )
        const foundFiles = await findSchemaFiles(searchDir)

        if (foundFiles.length === 0) {
          throw new Error(
            `–ù–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ 'schema.ts' –≤ ${searchDir}. –£–∫–∞–∂–∏ –ø—É—Ç—å –∫ —Å—Ö–µ–º–µ –≤—Ä—É—á–Ω—É—é.`,
          )
        }
        if (foundFiles.length > 1) {
          throw new Error(
            `–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤ 'schema.ts'. –£—Ç–æ—á–Ω–∏, –∫–∞–∫–æ–π –∏–∑ –Ω–∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –ø–µ—Ä–µ–¥–∞–≤ –ø—É—Ç—å –∫–∞–∫ —Ç—Ä–µ—Ç–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç:\n- ${foundFiles.join('\n- ')}`,
          )
        }

        schemaPath = foundFiles[0]
        console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ –æ–¥–Ω–∞ —Å—Ö–µ–º–∞: ${schemaPath}`)
      }
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ —Å—Ö–µ–º—ã
    try {
      await fs.access(schemaPath)
    } catch (error) {
      throw new Error(`–§–∞–π–ª —Å—Ö–µ–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: ${schemaPath}`)
    }

    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ–∞–π–ª —Å—Ö–µ–º—ã
    const schemaModule = await import(pathToFileURL(schemaPath).href)
    if (!schemaModule.components?.schemas) {
      throw new Error(
        '–û—à–∏–±–∫–∞ –≤ —Ñ–∞–π–ª–µ —Å—Ö–µ–º—ã: –Ω–µ –Ω–∞–π–¥–µ–Ω —ç–∫—Å–ø–æ—Ä—Ç `components` –∏–ª–∏ `components.schemas`.',
      )
    }

    const allSchemaNames = Object.keys(schemaModule.components.schemas)
    const entityTypeNames = allSchemaNames.filter((name) => name.startsWith(entity))

    if (entityTypeNames.length === 0) {
      console.warn(`‚ö†Ô∏è  –ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å—Ö–µ–º, –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö—Å—è —Å "${entity}". –§–∞–π–ª –Ω–µ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω.`)
      return
    }

    console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–æ ${entityTypeNames.length} DTO –¥–ª—è —Å—É—â–Ω–æ—Å—Ç–∏ "${entity}".`)

    let targetDir = path.resolve(targetPathInput)
    try {
      const targetStats = await fs.stat(targetDir)
      if (targetStats.isFile()) targetDir = path.dirname(targetDir)
    } catch {}

    await fs.mkdir(targetDir, { recursive: true })

    const relativePathToSchema = path
      .relative(targetDir, schemaPath)
      .replace(/\\/g, '/')
      .replace(/\.ts$/, '')
    const header = `/**
 * @file Data Transfer Objects for ${entity}.
 * @note This file was auto-generated by a script. Do not edit it manually.
 */\n
import type { components } from '${relativePathToSchema}';\n`

    const typeAliases = entityTypeNames
      .sort()
      .map((name) => `export type ${name} = components['schemas']['${name}'];`)
      .join('\n')
    const fileContent = `${header}\n${typeAliases}\n`
    const targetFilePath = path.join(targetDir, TARGET_FILENAME)

    await fs.writeFile(targetFilePath, fileContent, 'utf-8')
    console.log(`‚úÖ –§–∞–π–ª DTO —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω: ${targetFilePath}`)
  } catch (err) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ DTO: ${err.message}`)
    process.exit(1)
  }
}

main()
