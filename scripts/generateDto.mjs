import fs from 'fs/promises'
import path from 'path'
import process from 'process'

// --- КОНФИГУРАЦИЯ ---
const DEFAULT_SOURCE_DIR = 'src/shared/api'
const TARGET_FILENAME = 'dto.ts' // Имя целевого файла

// --- ХЕЛПЕРЫ ---
const toPascalCase = (str) => str.charAt(0).toUpperCase() + str.slice(1)

async function findTypesFiles(dir) {
  let results = []
  try {
    const list = await fs.readdir(dir)
    for (const file of list) {
      const filePath = path.resolve(dir, file)
      const stat = await fs.stat(filePath)
      if (stat?.isDirectory()) {
        results = results.concat(await findTypesFiles(filePath))
      } else if (path.basename(filePath) === 'types.ts') {
        results.push(filePath)
      }
    }
  } catch (error) {
    // Игнорируем ошибку, если директория не найдена
    if (error.code !== 'ENOENT') throw error
  }
  return results
}

const getAliasedImportPath = (sourceFile) => {
  const srcDir = path.resolve(process.cwd(), 'src')
  const relativePath = path.relative(srcDir, sourceFile)
  // Заменяем расширение .ts и разделители пути для корректного импорта
  return `@/${relativePath.replace(/\.ts$/, '').split(path.sep).join('/')}`
}

// --- ОСНОВНАЯ ЛОГИКА ---
const main = async () => {
  try {
    // Получаем аргументы из командной строки
    const [, , entityName, targetPathInput, serviceSubDirInput] = process.argv

    if (!entityName || !targetPathInput) {
      console.error('❌ Usage: command <EntityName> <TargetDirectory> [ServiceSubDir]')
      process.exit(1)
    }

    const serviceSubDir = serviceSubDirInput || ''
    const entity = toPascalCase(entityName)

    let targetDir = path.resolve(targetPathInput)
    // Если указан путь к файлу, берем его директорию
    try {
      const targetStats = await fs.stat(targetDir)
      if (targetStats.isFile()) {
        targetDir = path.dirname(targetDir)
      }
    } catch {
      // Если путь не существует, предполагаем, что это директория
    }

    const sourceDir = path.resolve(DEFAULT_SOURCE_DIR, serviceSubDir.trim())

    console.log(`ℹ️  Scanning for types in: ${sourceDir}`)
    const typeFiles = await findTypesFiles(sourceDir)

    if (typeFiles.length === 0) {
      throw new Error(`No 'types.ts' files found in ${sourceDir}`)
    }
    console.log(`✅ Found ${typeFiles.length} source file(s).`)

    let allTypeInfo = []
    const typeRegex = /^export type (\w+) =/gm
    for (const file of typeFiles) {
      const content = await fs.readFile(file, 'utf-8')
      const matches = [...content.matchAll(typeRegex)]
      matches.forEach((match) => {
        allTypeInfo.push({ typeName: match[1], sourcePath: file })
      })
    }

    // Фильтруем все типы, которые начинаются с имени сущности
    const entityTypeInfo = allTypeInfo.filter((info) => info.typeName.startsWith(entity))

    if (entityTypeInfo.length === 0) {
      console.warn(`⚠️  No types found starting with "${entity}". Nothing to generate.`)
      return
    }

    // Создаем директорию, если она не существует
    await fs.mkdir(targetDir, { recursive: true })

    // Группируем типы по исходному файлу для создания одного import'а на файл
    const groupedBySource = entityTypeInfo.reduce((acc, { typeName, sourcePath }) => {
      if (!acc[sourcePath]) {
        acc[sourcePath] = []
      }
      acc[sourcePath].push(typeName)
      return acc
    }, {})

    const exportStatements = Object.entries(groupedBySource)
      .map(([sourcePath, types]) => {
        const importPath = getAliasedImportPath(sourcePath)
        // Сортируем типы для консистентности
        return `export type { ${types.sort().join(', ')} } from '${importPath}';`
      })
      .sort() // Сортируем сами строки export для предсказуемого порядка
      .join('\n')

    const fileContent = `/**
 * @file Data Transfer Objects for ${entity}.
 * @note This file was auto-generated by a script. Do not edit it manually.
 */
${exportStatements}
`
    const targetFilePath = path.join(targetDir, TARGET_FILENAME)
    await fs.writeFile(targetFilePath, fileContent, 'utf-8')
    console.log(`✅ Successfully created DTO file: ${targetFilePath}`)
  } catch (err) {
    console.error(`❌ Error generating DTOs: ${err.message}`)
    process.exit(1)
  }
}

main()
