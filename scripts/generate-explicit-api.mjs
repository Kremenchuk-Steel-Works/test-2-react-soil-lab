import fs from 'fs/promises'
import path from 'path'
import ts from 'typescript'

// --- Конфигурация ---
const EXCLUDED_PATTERNS = [
  'index.ts',
  '.spec.ts',
  '.test.ts',
  '.d.ts',
  '.stories.tsx',
  '.story.tsx',
]
const TARGET_FILE_NAME = 'index.ts'
// --- Конец конфигурации ---

// Рекурсивно получаем все файлы в директории
async function getFiles(dir) {
  const dirents = await fs.readdir(dir, { withFileTypes: true })
  const files = await Promise.all(
    dirents.map((dirent) => {
      const res = path.resolve(dir, dirent.name)
      return dirent.isDirectory() ? getFiles(res) : res
    }),
  )
  return Array.prototype.concat(...files)
}

function isFileExcluded(filePath) {
  return EXCLUDED_PATTERNS.some((pattern) => filePath.endsWith(pattern))
}

// Главная функция, которая парсит файл и находит экспорты
function findExportsInFile(filePath) {
  const fileContent = fs.readFileSync(filePath, 'utf8')
  const sourceFile = ts.createSourceFile(filePath, fileContent, ts.ScriptTarget.ESNext, true)

  const valueExports = new Set()
  const typeExports = new Set()

  ts.forEachChild(sourceFile, (node) => {
    // Проверяем, есть ли у узла модификатор 'export'
    if (
      !ts.canHaveModifiers(node) ||
      !ts.getModifiers(node)?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      return
    }

    // export const moldPassportSchema = ...
    if (ts.isVariableStatement(node)) {
      node.declarationList.declarations.forEach((declaration) => {
        if (ts.isIdentifier(declaration.name)) {
          valueExports.add(declaration.name.text)
        }
      })
    }
    // export function myFunction() { ... }
    else if (ts.isFunctionDeclaration(node) && node.name) {
      valueExports.add(node.name.text)
    }
    // export class MyClass { ... }
    else if (ts.isClassDeclaration(node) && node.name) {
      valueExports.add(node.name.text)
    }
    // export type MyType = ...
    else if (ts.isTypeAliasDeclaration(node)) {
      typeExports.add(node.name.text)
    }
    // export interface MyInterface { ... }
    else if (ts.isInterfaceDeclaration(node)) {
      typeExports.add(node.name.text)
    }
    // export { name1, name2 }
    else if (
      ts.isExportDeclaration(node) &&
      node.exportClause &&
      ts.isNamedExports(node.exportClause)
    ) {
      node.exportClause.elements.forEach((element) => {
        if (element.isTypeOnly) {
          typeExports.add(element.name.text)
        } else {
          valueExports.add(element.name.text)
        }
      })
    }
  })

  return {
    values: Array.from(valueExports),
    types: Array.from(typeExports),
  }
}

async function main() {
  const targetDir = process.argv[2]
  if (!targetDir) {
    console.error('Ошибка: Укажи целевую директорию!')
    console.log('Пример: node scripts/generate-explicit-api.mjs src/entities/some-entity')
    process.exit(1)
  }

  const absoluteTargetDir = path.resolve(process.cwd(), targetDir)

  try {
    const allFiles = await getFiles(absoluteTargetDir)
    const tsFiles = allFiles.filter(
      (file) => (file.endsWith('.ts') || file.endsWith('.tsx')) && !isFileExcluded(file),
    )

    const allExportLines = []

    for (const file of tsFiles) {
      const { values, types } = findExportsInFile(file)
      if (values.length === 0 && types.length === 0) continue

      const relativePath = path.relative(absoluteTargetDir, file).replace(/\\/g, '/')
      const importPath = `./${relativePath.replace(/\.tsx?$/, '')}`

      if (values.length > 0) {
        allExportLines.push(`export { ${values.join(', ')} } from '${importPath}';`)
      }
      if (types.length > 0) {
        allExportLines.push(`export type { ${types.join(', ')} } from '${importPath}';`)
      }
    }

    if (allExportLines.length === 0) {
      console.log(`В директории ${targetDir} не найдено файлов с экспортами.`)
      return
    }

    const fileContent = `/**
 * @file Automatically generated by 'scripts/generate-explicit-api.mjs'.
 *
 * ⚠️ ВНИМАНИЕ! Этот файл был сгенерирован автоматически.
 * Ваша задача — просмотреть его и удалить те экспорты,
 * которые не должны быть частью публичного API этого модуля.
 */\n\n${allExportLines.join('\n')}\n`

    const outputPath = path.join(absoluteTargetDir, TARGET_FILE_NAME)
    await fs.writeFile(outputPath, fileContent)

    console.log(`✅ Явный публичный API сгенерирован: ${outputPath}`)
    console.log('下一步 (Next step): Просто взгляни на файл и удали лишние строки!')
  } catch (error) {
    console.error('Произошла ошибка:', error)
    process.exit(1)
  }
}

main()
