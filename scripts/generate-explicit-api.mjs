import fs from 'fs/promises'
import path from 'path'
import ts from 'typescript'

// --- Конфигурация ---
const EXCLUDED_PATTERNS = [
  'index.ts',
  '.spec.ts',
  '.test.ts',
  '.d.ts',
  '.stories.tsx',
  '.story.tsx',
]
const TARGET_FILE_NAME = 'index.ts'

async function getFiles(dir) {
  const dirents = await fs.readdir(dir, { withFileTypes: true })
  const files = await Promise.all(
    dirents.map((dirent) => {
      const res = path.resolve(dir, dirent.name)
      return dirent.isDirectory() ? getFiles(res) : res
    }),
  )
  return Array.prototype.concat(...files)
}

function isFileExcluded(filePath) {
  return EXCLUDED_PATTERNS.some((pattern) => filePath.endsWith(pattern))
}

async function findExportsInFile(filePath) {
  const fileContent = await fs.readFile(filePath, 'utf8')
  const sourceFile = ts.createSourceFile(filePath, fileContent, ts.ScriptTarget.ESNext, true)

  const valueExports = new Set()
  const typeExports = new Set()
  let defaultExportName = null

  ts.forEachChild(sourceFile, (node) => {
    const hasExportModifier = node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    const hasDefaultModifier = node.modifiers?.some((m) => m.kind === ts.SyntaxKind.DefaultKeyword)

    // Обработка 'export default function MyComponent() {}'
    if (hasExportModifier && hasDefaultModifier) {
      if ((ts.isFunctionDeclaration(node) || ts.isClassDeclaration(node)) && node.name) {
        defaultExportName = node.name.text
      }
    }

    if (!hasExportModifier) return

    // Обработка именованных экспортов
    if (ts.isVariableStatement(node)) {
      node.declarationList.declarations.forEach((declaration) => {
        if (ts.isIdentifier(declaration.name)) valueExports.add(declaration.name.text)
      })
    } else if (ts.isFunctionDeclaration(node) && node.name && !hasDefaultModifier) {
      valueExports.add(node.name.text)
    } else if (ts.isClassDeclaration(node) && node.name && !hasDefaultModifier) {
      valueExports.add(node.name.text)
    } else if (ts.isTypeAliasDeclaration(node)) {
      typeExports.add(node.name.text)
    } else if (ts.isInterfaceDeclaration(node)) {
      typeExports.add(node.name.text)
    } else if (
      ts.isExportDeclaration(node) &&
      node.exportClause &&
      ts.isNamedExports(node.exportClause)
    ) {
      node.exportClause.elements.forEach((element) => {
        if (element.isTypeOnly) {
          typeExports.add(element.name.text)
        } else {
          valueExports.add(element.name.text)
        }
      })
    }
  })

  return {
    values: Array.from(valueExports),
    types: Array.from(typeExports),
    defaultExport: defaultExportName,
  }
}

async function main() {
  const targetDir = process.argv[2]
  if (!targetDir) {
    console.error('Ошибка: Укажи целевую директорию!')
    process.exit(1)
  }

  const absoluteTargetDir = path.resolve(process.cwd(), targetDir)

  try {
    const allFiles = await getFiles(absoluteTargetDir)
    const tsFiles = allFiles.filter(
      (file) => (file.endsWith('.ts') || file.endsWith('.tsx')) && !isFileExcluded(file),
    )
    const allExportLines = []

    await Promise.all(
      tsFiles.map(async (file) => {
        const { values, types, defaultExport } = await findExportsInFile(file)
        if (values.length === 0 && types.length === 0 && !defaultExport) return

        const relativePath = path.relative(absoluteTargetDir, file).replace(/\\/g, '/')
        const importPath = `./${relativePath.replace(/\.tsx?$/, '')}`

        if (defaultExport) {
          allExportLines.push(`export { default as ${defaultExport} } from '${importPath}';`)
        }
        if (values.length > 0) {
          allExportLines.push(`export { ${values.join(', ')} } from '${importPath}';`)
        }
        if (types.length > 0) {
          allExportLines.push(`export type { ${types.join(', ')} } from '${importPath}';`)
        }
      }),
    )

    if (allExportLines.length === 0) {
      console.log(`В директории ${targetDir} не найдено файлов с экспортами.`)
      return
    }

    const fileContent = `/**
 * @file Automatically generated by 'scripts/generate-explicit-api.mjs'.
 */\n\n${allExportLines.sort().join('\n')}\n`

    const outputPath = path.join(absoluteTargetDir, TARGET_FILE_NAME)
    await fs.writeFile(outputPath, fileContent)

    console.log(`✅ Явный публичный API сгенерирован: ${outputPath}`)
    console.log('Просто взгляни на файл и удали лишние строки!')
  } catch (error) {
    console.error('Произошла ошибка:', error)
    process.exit(1)
  }
}

main()
